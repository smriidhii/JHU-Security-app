{"version":3,"file":"index.min.js","sources":["../node_modules/core-js/internals/global.js","../node_modules/core-js/internals/engine-v8-version.js","../node_modules/core-js/internals/fails.js","../node_modules/core-js/internals/descriptors.js","../node_modules/core-js/internals/object-property-is-enumerable.js","../node_modules/core-js/internals/create-property-descriptor.js","../node_modules/core-js/internals/classof-raw.js","../node_modules/core-js/internals/indexed-object.js","../node_modules/core-js/internals/require-object-coercible.js","../node_modules/core-js/internals/to-indexed-object.js","../node_modules/core-js/internals/is-callable.js","../node_modules/core-js/internals/is-object.js","../node_modules/core-js/internals/get-built-in.js","../node_modules/core-js/internals/engine-user-agent.js","../node_modules/core-js/internals/native-symbol.js","../node_modules/core-js/internals/use-symbol-as-uid.js","../node_modules/core-js/internals/is-symbol.js","../node_modules/core-js/internals/a-callable.js","../node_modules/core-js/internals/try-to-string.js","../node_modules/core-js/internals/set-global.js","../node_modules/core-js/internals/shared-store.js","../node_modules/core-js/internals/shared.js","../node_modules/core-js/internals/to-object.js","../node_modules/core-js/internals/has-own-property.js","../node_modules/core-js/internals/uid.js","../node_modules/core-js/internals/well-known-symbol.js","../node_modules/core-js/internals/to-primitive.js","../node_modules/core-js/internals/get-method.js","../node_modules/core-js/internals/ordinary-to-primitive.js","../node_modules/core-js/internals/to-property-key.js","../node_modules/core-js/internals/document-create-element.js","../node_modules/core-js/internals/ie8-dom-define.js","../node_modules/core-js/internals/object-get-own-property-descriptor.js","../node_modules/core-js/internals/an-object.js","../node_modules/core-js/internals/object-define-property.js","../node_modules/core-js/internals/create-non-enumerable-property.js","../node_modules/core-js/internals/inspect-source.js","../node_modules/core-js/internals/internal-state.js","../node_modules/core-js/internals/native-weak-map.js","../node_modules/core-js/internals/shared-key.js","../node_modules/core-js/internals/hidden-keys.js","../node_modules/core-js/internals/function-name.js","../node_modules/core-js/internals/redefine.js","../node_modules/core-js/internals/to-integer-or-infinity.js","../node_modules/core-js/internals/to-absolute-index.js","../node_modules/core-js/internals/to-length.js","../node_modules/core-js/internals/length-of-array-like.js","../node_modules/core-js/internals/array-includes.js","../node_modules/core-js/internals/object-keys-internal.js","../node_modules/core-js/internals/enum-bug-keys.js","../node_modules/core-js/internals/object-get-own-property-names.js","../node_modules/core-js/internals/object-get-own-property-symbols.js","../node_modules/core-js/internals/own-keys.js","../node_modules/core-js/internals/copy-constructor-properties.js","../node_modules/core-js/internals/is-forced.js","../node_modules/core-js/internals/export.js","../node_modules/core-js/internals/is-array.js","../node_modules/core-js/internals/to-string-tag-support.js","../node_modules/core-js/internals/classof.js","../node_modules/core-js/internals/is-constructor.js","../node_modules/core-js/internals/array-species-constructor.js","../node_modules/core-js/internals/array-species-create.js","../node_modules/core-js/internals/array-iteration.js","../node_modules/core-js/internals/function-bind-context.js","../node_modules/core-js/internals/array-method-has-species-support.js","../node_modules/core-js/modules/es.array.map.js","../node_modules/core-js/modules/es.array.filter.js","../node_modules/core-js/internals/array-method-is-strict.js","../src/cluster.ts","../src/algorithms/utils.ts","../src/algorithms/core.ts","../node_modules/core-js/internals/dom-iterables.js","../node_modules/core-js/internals/dom-token-list-prototype.js","../node_modules/core-js/internals/array-for-each.js","../node_modules/core-js/modules/web.dom-collections.for-each.js","../node_modules/core-js/modules/web.url.to-json.js","../src/algorithms/grid.ts","../src/algorithms/noop.ts","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/skmeans/dist/node/distance.js","../node_modules/skmeans/dist/node/kinit.js","../node_modules/skmeans/dist/node/main.js","../src/algorithms/kmeans.ts","../node_modules/@turf/clusters-kmeans/dist/es/index.js","../node_modules/core-js/internals/object-keys.js","../node_modules/core-js/internals/object-assign.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/core-js/modules/es.object.assign.js","../node_modules/density-clustering/lib/DBSCAN.js","../node_modules/density-clustering/lib/KMEANS.js","../node_modules/density-clustering/lib/PriorityQueue.js","../node_modules/density-clustering/lib/OPTICS.js","../node_modules/density-clustering/lib/index.js","../src/algorithms/dbscan.ts","../node_modules/@turf/clusters-dbscan/dist/es/index.js","../node_modules/kdbush/src/sort.js","../node_modules/kdbush/src/within.js","../node_modules/kdbush/src/index.js","../node_modules/kdbush/src/range.js","../node_modules/supercluster/index.js","../node_modules/fast-deep-equal/es6/index.js","../node_modules/core-js/internals/object-create.js","../src/algorithms/supercluster.ts","../node_modules/core-js/internals/object-define-properties.js","../node_modules/core-js/internals/html.js","../node_modules/core-js/internals/add-to-unscopables.js","../node_modules/core-js/modules/es.array.includes.js","../node_modules/core-js/internals/is-regexp.js","../node_modules/core-js/internals/not-a-regexp.js","../node_modules/core-js/internals/to-string.js","../node_modules/core-js/internals/correct-is-regexp-logic.js","../node_modules/core-js/modules/es.string.includes.js","../node_modules/core-js/internals/create-property.js","../node_modules/core-js/modules/es.array.splice.js","../node_modules/core-js/internals/a-possible-prototype.js","../node_modules/core-js/internals/object-set-prototype-of.js","../node_modules/core-js/internals/inherit-if-required.js","../node_modules/core-js/internals/this-number-value.js","../node_modules/core-js/internals/string-trim.js","../node_modules/core-js/modules/es.number.constructor.js","../src/renderer.ts","../src/markerclusterer.ts","../src/overlay-view-safe.ts"],"sourcesContent":["var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] < 4 ? 1 : match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n","// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument === 'function';\n};\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : isCallable(it);\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var isCallable = require('../internals/is-callable');\nvar getBuiltIn = require('../internals/get-built-in');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && Object(it) instanceof $Symbol;\n};\n","var isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw TypeError(tryToString(argument) + ' is not a function');\n};\n","module.exports = function (argument) {\n  try {\n    return String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","var global = require('../internals/global');\n\nmodule.exports = function (key, value) {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.18.2',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'\n});\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n","var toObject = require('../internals/to-object');\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty.call(toObject(it), key);\n};\n","var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar hasOwn = require('../internals/has-own-property');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","var isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = exoticToPrim.call(input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","var aCallable = require('../internals/a-callable');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n","var isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : String(key);\n};\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var DESCRIPTORS = require('../internals/descriptors');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar hasOwn = require('../internals/has-own-property');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n","var isObject = require('../internals/is-object');\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw TypeError(String(argument) + ' is not an object');\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = Function.toString;\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","module.exports = {};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar hasOwn = require('../internals/has-own-property');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar hasOwn = require('../internals/has-own-property');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar setGlobal = require('../internals/set-global');\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var name = options && options.name !== undefined ? options.name : key;\n  var state;\n  if (isCallable(value)) {\n    if (String(name).slice(0, 7) === 'Symbol(') {\n      name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n    }\n    if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n      createNonEnumerableProperty(value, 'name', name);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n});\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- safe\n  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);\n};\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var toLength = require('../internals/to-length');\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","var hasOwn = require('../internals/has-own-property');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var getBuiltIn = require('../internals/get-built-in');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","var hasOwn = require('../internals/has-own-property');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n","var classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) == 'Array';\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n","var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar classof = require('../internals/classof');\nvar getBuiltIn = require('../internals/get-built-in');\nvar inspectSource = require('../internals/inspect-source');\n\nvar empty = [];\nvar construct = getBuiltIn('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = constructorRegExp.exec;\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(function () { /* empty */ });\n\nvar isConstructorModern = function (argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(Object, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function (argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n    // we can't check .prototype since constructors produced by .bind haven't it\n  } return INCORRECT_TO_STRING || !!exec.call(constructorRegExp, inspectSource(argument));\n};\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nmodule.exports = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n","var isArray = require('../internals/is-array');\nvar isConstructor = require('../internals/is-constructor');\nvar isObject = require('../internals/is-object');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","var arraySpeciesConstructor = require('../internals/array-species-constructor');\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n","var bind = require('../internals/function-bind-context');\nvar IndexedObject = require('../internals/indexed-object');\nvar toObject = require('../internals/to-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar arraySpeciesCreate = require('../internals/array-species-create');\n\nvar push = [].push;\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that, 3);\n    var length = lengthOfArrayLike(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push.call(target, value); // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push.call(target, value); // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod(7)\n};\n","var aCallable = require('../internals/a-callable');\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aCallable(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","var fails = require('../internals/fails');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar V8_VERSION = require('../internals/engine-v8-version');\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $map = require('../internals/array-iteration').map;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar $filter = require('../internals/array-iteration').filter;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ClusterOptions {\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  markers?: google.maps.Marker[];\n}\n\nexport class Cluster {\n  public marker: google.maps.Marker;\n  public readonly markers?: google.maps.Marker[];\n  protected _position: google.maps.LatLng;\n\n  constructor({ markers, position }: ClusterOptions) {\n    this.markers = markers;\n\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n\n  public get bounds(): google.maps.LatLngBounds | undefined {\n    if (this.markers.length === 0 && !this._position) {\n      return undefined;\n    }\n\n    return this.markers.reduce((bounds, marker) => {\n      return bounds.extend(marker.getPosition());\n    }, new google.maps.LatLngBounds(this._position, this._position));\n  }\n\n  public get position(): google.maps.LatLng {\n    return this._position || this.bounds.getCenter();\n  }\n\n  /**\n   * Get the count of **visible** markers.\n   */\n  public get count(): number {\n    return this.markers.filter((m: google.maps.Marker) => m.getVisible())\n      .length;\n  }\n\n  /**\n   * Add a marker to the cluster.\n   */\n  public push(marker: google.maps.Marker): void {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  public delete(): void {\n    if (this.marker) {\n      this.marker.setMap(null);\n      delete this.marker;\n    }\n    this.markers.length = 0;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const filterMarkersToPaddedViewport = (\n  map: google.maps.Map,\n  mapCanvasProjection: google.maps.MapCanvasProjection,\n  markers: google.maps.Marker[],\n  viewportPadding: number\n): google.maps.Marker[] => {\n  const extendedMapBounds = extendBoundsToPaddedViewport(\n    map.getBounds(),\n    mapCanvasProjection,\n    viewportPadding\n  );\n  return markers.filter((marker) =>\n    extendedMapBounds.contains(marker.getPosition())\n  );\n};\n\n/**\n * Extends a bounds by a number of pixels in each direction.\n */\nexport const extendBoundsToPaddedViewport = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection,\n  pixels: number\n): google.maps.LatLngBounds => {\n  const { northEast, southWest } = latLngBoundsToPixelBounds(\n    bounds,\n    projection\n  );\n  const extendedPixelBounds = extendPixelBounds(\n    { northEast, southWest },\n    pixels\n  );\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n\n/**\n * @hidden\n */\nexport const distanceBetweenPoints = (\n  p1: google.maps.LatLngLiteral,\n  p2: google.maps.LatLngLiteral\n): number => {\n  const R = 6371; // Radius of the Earth in km\n  const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((p1.lat * Math.PI) / 180) *\n      Math.cos((p2.lat * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\ntype PixelBounds = {\n  northEast: google.maps.Point;\n  southWest: google.maps.Point;\n};\n\n/**\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection\n): PixelBounds => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n  };\n};\n\n/**\n * @hidden\n */\nexport const extendPixelBounds = (\n  { northEast, southWest }: PixelBounds,\n  pixels: number\n): PixelBounds => {\n  northEast.x += pixels;\n  northEast.y -= pixels;\n\n  southWest.x -= pixels;\n  southWest.y += pixels;\n\n  return { northEast, southWest };\n};\n\n/**\n * @hidden\n */\nexport const pixelBoundsToLatLngBounds = (\n  { northEast, southWest }: PixelBounds,\n  projection: google.maps.MapCanvasProjection\n): google.maps.LatLngBounds => {\n  const bounds = new google.maps.LatLngBounds();\n  bounds.extend(projection.fromDivPixelToLatLng(northEast));\n  bounds.extend(projection.fromDivPixelToLatLng(southWest));\n  return bounds;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"../cluster\";\nimport { filterMarkersToPaddedViewport } from \"./utils\";\n\nexport interface AlgorithmInput {\n  /**\n   * The map containing the markers and clusters.\n   */\n  map: google.maps.Map;\n  /**\n   * An array of markers to be clustered.\n   *\n   * There are some specific edge cases to be aware of including the following:\n   * * Markers that are not visible.\n   */\n  markers: google.maps.Marker[];\n  /**\n   * The `mapCanvasProjection` enables easy conversion from lat/lng to pixel.\n   *\n   * @see [MapCanvasProjection](https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapCanvasProjection)\n   */\n  mapCanvasProjection: google.maps.MapCanvasProjection;\n}\n\nexport interface AlgorithmOutput {\n  /**\n   * The clusters returned based upon the {@link AlgorithmInput}.\n   */\n  clusters: Cluster[];\n  /**\n   * A boolean flag indicating that the clusters have not changed.\n   */\n  changed?: boolean;\n}\n\nexport interface Algorithm {\n  /**\n   * Calculates an array of {@link Cluster}.\n   */\n  calculate: ({ markers, map }: AlgorithmInput) => AlgorithmOutput;\n}\n\nexport interface AlgorithmOptions {\n  maxZoom?: number;\n}\n/**\n * @hidden\n */\nexport abstract class AbstractAlgorithm implements Algorithm {\n  protected maxZoom: number;\n\n  constructor({ maxZoom = 16 }: AlgorithmOptions) {\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers, map})\n   *    }\n   * }\n   * ```\n   */\n  protected noop({ markers }: AlgorithmInput): Cluster[] {\n    return noop(markers);\n  }\n  /**\n   * Calculates an array of {@link Cluster}. Calculate is separate from\n   * {@link cluster} as it does preprocessing on the markers such as filtering\n   * based upon the viewport as in {@link AbstractViewportAlgorithm}. Caching\n   * and other optimizations can also be done here.\n   */\n  public abstract calculate({ markers, map }: AlgorithmInput): AlgorithmOutput;\n\n  /**\n   * Clusters the markers and called from {@link calculate}.\n   */\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport interface ViewportAlgorithmOptions extends AlgorithmOptions {\n  /**\n   * The number of pixels to extend beyond the viewport bounds when filtering\n   * markers prior to clustering.\n   */\n  viewportPadding?: number;\n}\n\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nexport abstract class AbstractViewportAlgorithm extends AbstractAlgorithm {\n  protected viewportPadding = 60;\n\n  constructor({ viewportPadding = 60, ...options }: ViewportAlgorithmOptions) {\n    super(options);\n    this.viewportPadding = viewportPadding;\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): AlgorithmOutput {\n    if (map.getZoom() >= this.maxZoom) {\n      return {\n        clusters: this.noop({\n          markers,\n          map,\n          mapCanvasProjection,\n        }),\n        changed: false,\n      };\n    }\n\n    return {\n      clusters: this.cluster({\n        markers: filterMarkersToPaddedViewport(\n          map,\n          mapCanvasProjection,\n          markers,\n          this.viewportPadding\n        ),\n        map,\n        mapCanvasProjection,\n      }),\n    };\n  }\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport const noop = (markers: google.maps.Marker[]): Cluster[] => {\n  const clusters = markers.map(\n    (marker) =>\n      new Cluster({\n        position: marker.getPosition(),\n        markers: [marker],\n      })\n  );\n  return clusters;\n};\n","// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n","// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = require('../internals/document-create-element');\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;\n\nmodule.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;\n","'use strict';\nvar $forEach = require('../internals/array-iteration').forEach;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\n\nvar STRICT_METHOD = arrayMethodIsStrict('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nmodule.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n} : [].forEach;\n","var global = require('../internals/global');\nvar DOMIterables = require('../internals/dom-iterables');\nvar DOMTokenListPrototype = require('../internals/dom-token-list-prototype');\nvar forEach = require('../internals/array-for-each');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nvar handlePrototype = function (CollectionPrototype) {\n  // some Chrome versions have non-configurable methods on DOMTokenList\n  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);\n  } catch (error) {\n    CollectionPrototype.forEach = forEach;\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  if (DOMIterables[COLLECTION_NAME]) {\n    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);\n  }\n}\n\nhandlePrototype(DOMTokenListPrototype);\n","'use strict';\nvar $ = require('../internals/export');\n\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\n$({ target: 'URL', proto: true, enumerable: true }, {\n  toJSON: function toJSON() {\n    return URL.prototype.toString.call(this);\n  }\n});\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { distanceBetweenPoints, extendBoundsToPaddedViewport } from \"./utils\";\n\nimport { Cluster } from \"../cluster\";\n\nexport interface GridOptions extends ViewportAlgorithmOptions {\n  gridSize?: number;\n  /**\n   * Max distance between cluster center and point in meters.\n   * @default 10000\n   */\n  maxDistance?: number;\n}\n\n/**\n * The default Grid algorithm historically used in Google Maps marker\n * clustering.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n */\nexport class GridAlgorithm extends AbstractViewportAlgorithm {\n  protected gridSize: number;\n  protected maxDistance: number;\n  protected clusters: Cluster[] = [];\n\n  constructor({ maxDistance = 40000, gridSize = 40, ...options }: GridOptions) {\n    super(options);\n\n    this.maxDistance = maxDistance;\n    this.gridSize = gridSize;\n  }\n\n  protected cluster({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    this.clusters = [];\n    markers.forEach((marker) => {\n      this.addToClosestCluster(marker, map, mapCanvasProjection);\n    });\n\n    return this.clusters;\n  }\n\n  protected addToClosestCluster(\n    marker: google.maps.Marker,\n    map: google.maps.Map,\n    projection: google.maps.MapCanvasProjection\n  ): void {\n    let maxDistance = this.maxDistance; // Some large number\n    let cluster: Cluster = null;\n\n    for (let i = 0; i < this.clusters.length; i++) {\n      const candidate = this.clusters[i];\n      const distance = distanceBetweenPoints(\n        candidate.bounds.getCenter().toJSON(),\n        marker.getPosition().toJSON()\n      );\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        cluster = candidate;\n      }\n    }\n\n    if (\n      cluster &&\n      extendBoundsToPaddedViewport(\n        cluster.bounds,\n        projection,\n        this.gridSize\n      ).contains(marker.getPosition())\n    ) {\n      cluster.push(marker);\n    } else {\n      const cluster = new Cluster({ markers: [marker] });\n      this.clusters.push(cluster);\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractAlgorithm,\n  AlgorithmInput,\n  AlgorithmOptions,\n  AlgorithmOutput,\n} from \"./core\";\n\nimport { Cluster } from \"../cluster\";\n\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nexport class NoopAlgorithm extends AbstractAlgorithm {\n  constructor({ ...options }: AlgorithmOptions) {\n    super(options);\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): AlgorithmOutput {\n    return {\n      clusters: this.cluster({ markers, map, mapCanvasProjection }),\n      changed: false,\n    };\n  }\n\n  protected cluster(input: AlgorithmInput): Cluster[] {\n    return this.noop(input);\n  }\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","\"use strict\";\n\nmodule.exports = {\n\t/**\n  * Euclidean distance\n  */\n\teudist: function eudist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar d = (v1[i] || 0) - (v2[i] || 0);\n\t\t\tsum += d * d;\n\t\t}\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\tmandist: function mandist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tsum += Math.abs((v1[i] || 0) - (v2[i] || 0));\n\t\t}\n\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\n\n\t/**\n  * Unidimensional distance\n  */\n\tdist: function dist(v1, v2, sqrt) {\n\t\tvar d = Math.abs(v1 - v2);\n\t\treturn sqrt ? d : d * d;\n\t}\n};\n//# sourceMappingURL=distance.js.map\n","\"use strict\";\n\nvar Distance = require(\"./distance.js\"),\n    eudist = Distance.eudist,\n    dist = Distance.dist;\n\nmodule.exports = {\n\tkmrand: function kmrand(data, k) {\n\t\tvar map = {},\n\t\t    ks = [],\n\t\t    t = k << 2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length > 0;\n\n\t\twhile (ks.length < k && t-- > 0) {\n\t\t\tvar d = data[Math.floor(Math.random() * len)];\n\t\t\tvar key = multi ? d.join(\"_\") : \"\" + d;\n\t\t\tif (!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n\t},\n\n\n\t/**\n  * K-means++ initial centroid selection\n  */\n\tkmpp: function kmpp(data, k) {\n\t\tvar distance = data[0].length ? eudist : dist;\n\t\tvar ks = [],\n\t\t    len = data.length;\n\t\tvar multi = data[0].length > 0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random() * len)];\n\t\tvar key = multi ? c.join(\"_\") : \"\" + c;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile (ks.length < k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tvar dists = [],\n\t\t\t    lk = ks.length;\n\t\t\tvar dsum = 0,\n\t\t\t    prs = [];\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar min = Infinity;\n\t\t\t\tfor (var j = 0; j < lk; j++) {\n\t\t\t\t\tvar _dist = distance(data[i], ks[j]);\n\t\t\t\t\tif (_dist <= min) min = _dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tdsum += dists[_i];\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\tprs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort(function (a, b) {\n\t\t\t\treturn a.pr - b.pr;\n\t\t\t});\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor (var _i3 = 1; _i3 < len; _i3++) {\n\t\t\t\tprs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tvar rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tvar idx = 0;\n\t\t\twhile (idx < len - 1 && prs[idx++].cs < rnd) {}\n\t\t\tks.push(prs[idx - 1].v);\n\t\t\t/*\n   let done = false;\n   while(!done) {\n   \t// this is our new centroid\n   \tc = prs[idx-1].v\n   \tkey = multi? c.join(\"_\") : `${c}`;\n   \tif(!map[key]) {\n   \t\tmap[key] = true;\n   \t\tks.push(c);\n   \t\tdone = true;\n   \t}\n   \telse {\n   \t\tidx++;\n   \t}\n   }\n   */\n\t\t}\n\n\t\treturn ks;\n\t}\n};\n//# sourceMappingURL=kinit.js.map\n","\"use strict\";\n\n/*jshint esversion: 6 */\n\nvar Distance = require(\"./distance.js\"),\n    ClusterInit = require(\"./kinit.js\"),\n    eudist = Distance.eudist,\n    mandist = Distance.mandist,\n    dist = Distance.dist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n\tv = v || [];\n\tfor (var i = 0; i < len; i++) {\n\t\tv[i] = val;\n\t}return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n\tvar ks = [],\n\t    old = [],\n\t    idxs = [],\n\t    dist = [];\n\tvar conv = false,\n\t    it = maxit || MAX;\n\tvar len = data.length,\n\t    vlen = data[0].length,\n\t    multi = vlen > 0;\n\tvar count = [];\n\n\tif (!initial) {\n\t\tvar _idxs = {};\n\t\twhile (ks.length < k) {\n\t\t\tvar idx = Math.floor(Math.random() * len);\n\t\t\tif (!_idxs[idx]) {\n\t\t\t\t_idxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t} else if (initial == \"kmrand\") {\n\t\tks = kmrand(data, k);\n\t} else if (initial == \"kmpp\") {\n\t\tks = kmpp(data, k);\n\t} else {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k, 0, count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar min = Infinity,\n\t\t\t    _idx = 0;\n\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\t\t\t\tif (dist <= min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\t_idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = _idx; // Index of the selected centroid for that value\n\t\t\tcount[_idx]++; // Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [],\n\t\t    old = [],\n\t\t    dif = 0;\n\t\tfor (var _j = 0; _j < k; _j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n\t\t\told[_j] = ks[_j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif (multi) {\n\t\t\tfor (var _j2 = 0; _j2 < k; _j2++) {\n\t\t\t\tks[_j2] = [];\n\t\t\t} // Sum values and count for each centroid\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tvar _idx2 = idxs[_i],\n\t\t\t\t    // Centroid for that item\n\t\t\t\tvsum = sum[_idx2],\n\t\t\t\t    // Sum values for this centroid\n\t\t\t\tvect = data[_i]; // Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor (var h = 0; h < vlen; h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor (var _j3 = 0; _j3 < k; _j3++) {\n\t\t\t\tvar ksj = ks[_j3],\n\t\t\t\t    // Current centroid\n\t\t\t\tsumj = sum[_j3],\n\t\t\t\t    // Accumulated centroid values\n\t\t\t\toldj = old[_j3],\n\t\t\t\t    // Old centroid value\n\t\t\t\tcj = count[_j3]; // Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor (var _h = 0; _h < vlen; _h++) {\n\t\t\t\t\tksj[_h] = sumj[_h] / cj || 0; // New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif (conv) {\n\t\t\t\t\tfor (var _h2 = 0; _h2 < vlen; _h2++) {\n\t\t\t\t\t\tif (oldj[_h2] != ksj[_h2]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t\t// Sum values and count for each centroid\n\t\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\t\tvar _idx3 = idxs[_i2];\n\t\t\t\t\tsum[_idx3] += data[_i2];\n\t\t\t\t}\n\t\t\t\t// Calculate the average for each centroid\n\t\t\t\tfor (var _j4 = 0; _j4 < k; _j4++) {\n\t\t\t\t\tks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n\t\t\t\t}\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tconv = true;\n\t\t\t\tfor (var _j5 = 0; _j5 < k; _j5++) {\n\t\t\t\t\tif (old[_j5] != ks[_j5]) {\n\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tconv = conv || --it <= 0;\n\t} while (!conv);\n\n\treturn {\n\t\tit: MAX - it,\n\t\tk: k,\n\t\tidxs: idxs,\n\t\tcentroids: ks\n\t};\n}\n\nmodule.exports = skmeans;\n//# sourceMappingURL=main.js.map\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersKmeans from \"@turf/clusters-kmeans\";\n\nexport interface KmeansAlgorithmOptions extends ViewportAlgorithmOptions {\n  numberOfClusters: number | ((count: number, zoom: number) => number);\n}\n\n/**\n * Experimental algorithm using Kmeans.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-kmeans\n */\nexport class KmeansAlgorithm extends AbstractViewportAlgorithm {\n  protected numberOfClusters:\n    | number\n    | ((count: number, zoom: number) => number);\n\n  constructor({ numberOfClusters, ...options }: KmeansAlgorithmOptions) {\n    super(options);\n    this.numberOfClusters = numberOfClusters;\n  }\n\n  protected cluster({ markers, map }: AlgorithmInput): Cluster[] {\n    const clusters: Cluster[] = [];\n\n    if (markers.length === 0) {\n      return clusters;\n    }\n    const points = featureCollection(\n      markers.map((marker) => {\n        return point([marker.getPosition().lng(), marker.getPosition().lat()]);\n      })\n    );\n\n    let numberOfClusters: number;\n\n    if (this.numberOfClusters instanceof Function) {\n      numberOfClusters = this.numberOfClusters(markers.length, map.getZoom());\n    } else {\n      numberOfClusters = this.numberOfClusters;\n    }\n    clustersKmeans(points, { numberOfClusters }).features.forEach(\n      (point, i) => {\n        if (!clusters[point.properties.cluster]) {\n          clusters[point.properties.cluster] = new Cluster({\n            position: {\n              lng: point.properties.centroid[0],\n              lat: point.properties.centroid[1],\n            },\n            markers: [],\n          });\n        }\n\n        clusters[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return clusters;\n  }\n}\n","import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(points, options) {\n    if (options === void 0) { options = {}; }\n    // Default Params\n    var count = points.features.length;\n    options.numberOfClusters =\n        options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n    // numberOfClusters can't be greater than the number of points\n    // fallbacks to count\n    if (options.numberOfClusters > count)\n        options.numberOfClusters = count;\n    // Clone points to prevent any mutations (enabled by default)\n    if (options.mutate !== true)\n        points = clone(points);\n    // collect points coordinates\n    var data = coordAll(points);\n    // create seed to avoid skmeans to drift\n    var initialCentroids = data.slice(0, options.numberOfClusters);\n    // create skmeans clusters\n    var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n    // store centroids {clusterId: [number, number]}\n    var centroids = {};\n    skmeansResult.centroids.forEach(function (coord, idx) {\n        centroids[idx] = coord;\n    });\n    // add associated cluster number\n    featureEach(points, function (point, index) {\n        var clusterId = skmeansResult.idxs[index];\n        point.properties.cluster = clusterId;\n        point.properties.centroid = centroids[clusterId];\n    });\n    return points;\n}\nexport default clustersKmeans;\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar objectKeys = require('../internals/object-keys');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","var $ = require('../internals/export');\nvar assign = require('../internals/object-assign');\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {\n  assign: assign\n});\n","/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\r\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {Array} */\r\n  this.dataset = [];\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 2;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n  /** @type {Array} */\r\n  this.clusters = [];\r\n  /** @type {Array} */\r\n  this.noise = [];\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._visited = [];\r\n  /** @type {Array} */\r\n  this._assigned = [];\r\n  /** @type {number} */\r\n  this._datasetLength = 0;\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n};\r\n\r\n/******************************************************************************/\r\n// public functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nDBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\r\n    // if point is not visited, check if it forms a cluster\r\n    if (this._visited[pointId] !== 1) {\r\n      this._visited[pointId] = 1;\r\n\r\n      // if closest neighborhood is too small to form a cluster, mark as noise\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      if (neighbors.length < this.minPts) {\r\n        this.noise.push(pointId);\r\n      } else {\r\n        // create new cluster and add point\r\n        var clusterId = this.clusters.length;\r\n        this.clusters.push([]);\r\n        this._addToCluster(pointId, clusterId);\r\n\r\n        this._expandCluster(clusterId, neighbors);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this.noise = [];\r\n\r\n    this._datasetLength = dataset.length;\r\n    this._visited = new Array(this._datasetLength);\r\n    this._assigned = new Array(this._datasetLength);\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._expandCluster = function(clusterId, neighbors) {\r\n\r\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\r\n  for (var i = 0; i < neighbors.length; i++) {\r\n    var pointId2 = neighbors[i];\r\n\r\n    if (this._visited[pointId2] !== 1) {\r\n      this._visited[pointId2] = 1;\r\n      var neighbors2 = this._regionQuery(pointId2);\r\n\r\n      if (neighbors2.length >= this.minPts) {\r\n        neighbors = this._mergeArrays(neighbors, neighbors2);\r\n      }\r\n    }\r\n\r\n    // add to cluster\r\n    if (this._assigned[pointId2] !== 1) {\r\n      this._addToCluster(pointId2, clusterId);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\r\nDBSCAN.prototype._addToCluster = function(pointId, clusterId) {\r\n  this.clusters[clusterId].push(pointId);\r\n  this._assigned[pointId] = 1;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._regionQuery = function(pointId) {\r\n  var neighbors = [];\r\n\r\n  for (var id = 0; id < this._datasetLength; id++) {\r\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\r\n    if (dist < this.epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._mergeArrays = function(a, b) {\r\n  var len = b.length;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var P = b[i];\r\n    if (a.indexOf(P) < 0) {\r\n      a.push(P);\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = DBSCAN;\r\n}\r\n","﻿/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\r\n function KMEANS(dataset, k, distance) {\r\n  this.k = 3; // number of clusters\r\n  this.dataset = []; // set of feature vectors\r\n  this.assignments = []; // set of associated clusters for each feature vector\r\n  this.centroids = []; // vectors for our clusters\r\n\r\n  this.init(dataset, k, distance);\r\n}\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.init = function(dataset, k, distance) {\r\n  this.assignments = [];\r\n  this.centroids = [];\r\n\r\n  if (typeof dataset !== 'undefined') {\r\n    this.dataset = dataset;\r\n  }\r\n\r\n  if (typeof k !== 'undefined') {\r\n    this.k = k;\r\n  }\r\n\r\n  if (typeof distance !== 'undefined') {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.run = function(dataset, k) {\r\n  this.init(dataset, k);\r\n\r\n  var len = this.dataset.length;\r\n\r\n  // initialize centroids\r\n  for (var i = 0; i < this.k; i++) {\r\n    this.centroids[i] = this.randomCentroid();\r\n\t}\r\n\r\n  var change = true;\r\n  while(change) {\r\n\r\n    // assign feature vectors to clusters\r\n    change = this.assign();\r\n\r\n    // adjust location of centroids\r\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\r\n      var mean = new Array(maxDim);\r\n      var count = 0;\r\n\r\n      // init mean vector\r\n      for (var dim = 0; dim < maxDim; dim++) {\r\n        mean[dim] = 0;\r\n      }\r\n\r\n      for (var j = 0; j < len; j++) {\r\n        var maxDim = this.dataset[j].length;\r\n\r\n        // if current cluster id is assigned to point\r\n        if (centroidId === this.assignments[j]) {\r\n          for (var dim = 0; dim < maxDim; dim++) {\r\n            mean[dim] += this.dataset[j][dim];\r\n          }\r\n          count++;\r\n        }\r\n      }\r\n\r\n      if (count > 0) {\r\n        // if cluster contain points, adjust centroid position\r\n        for (var dim = 0; dim < maxDim; dim++) {\r\n          mean[dim] /= count;\r\n        }\r\n        this.centroids[centroidId] = mean;\r\n      } else {\r\n        // if cluster is empty, generate new random centroid\r\n        this.centroids[centroidId] = this.randomCentroid();\r\n        change = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.getClusters();\r\n};\r\n\r\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\r\nKMEANS.prototype.randomCentroid = function() {\r\n  var maxId = this.dataset.length -1;\r\n  var centroid;\r\n  var id;\r\n\r\n  do {\r\n    id = Math.round(Math.random() * maxId);\r\n    centroid = this.dataset[id];\r\n  } while (this.centroids.indexOf(centroid) >= 0);\r\n\r\n  return centroid;\r\n}\r\n\r\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\r\nKMEANS.prototype.assign = function() {\r\n  var change = false;\r\n  var len = this.dataset.length;\r\n  var closestCentroid;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\r\n\r\n    if (closestCentroid != this.assignments[i]) {\r\n      this.assignments[i] = closestCentroid;\r\n      change = true;\r\n    }\r\n  }\r\n\r\n  return change;\r\n}\r\n\r\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.getClusters = function() {\r\n  var clusters = new Array(this.k);\r\n  var centroidId;\r\n\r\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\r\n    centroidId = this.assignments[pointId];\r\n\r\n    // init empty cluster\r\n    if (typeof clusters[centroidId] === 'undefined') {\r\n      clusters[centroidId] = [];\r\n    }\r\n\r\n    clusters[centroidId].push(pointId);\r\n  }\r\n\r\n  return clusters;\r\n};\r\n\r\n// utils\r\n\r\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.argmin = function(point, set, f) {\r\n  var min = Number.MAX_VALUE;\r\n  var arg = 0;\r\n  var len = set.length;\r\n  var d;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    d = f(point, set[i]);\r\n    if (d < min) {\r\n      min = d;\r\n      arg = i;\r\n    }\r\n  }\r\n\r\n  return arg;\r\n};\r\n\r\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.distance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    var diff = p[i] - q[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = KMEANS;\r\n}\r\n","/**\r\n * PriorityQueue\r\n * Elements in this queue are sorted according to their value\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * PriorityQueue class construcotr\r\n * @constructor\r\n *\r\n * @example\r\n * queue: [1,2,3,4]\r\n * priorities: [4,1,2,3]\r\n * > result = [1,4,2,3]\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @param {string} sorting - asc / desc\r\n * @returns {PriorityQueue}\r\n */\r\nfunction PriorityQueue(elements, priorities, sorting) {\r\n  /** @type {Array} */\r\n  this._queue = [];\r\n  /** @type {Array} */\r\n  this._priorities = [];\r\n  /** @type {string} */\r\n  this._sorting = 'desc';\r\n\r\n  this._init(elements, priorities, sorting);\r\n};\r\n\r\n/**\r\n * Insert element\r\n *\r\n * @param {Object} ele\r\n * @param {Object} priority\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.insert = function(ele, priority) {\r\n  var indexToInsert = this._queue.length;\r\n  var index = indexToInsert;\r\n\r\n  while (index--) {\r\n    var priority2 = this._priorities[index];\r\n    if (this._sorting === 'desc') {\r\n      if (priority > priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    } else {\r\n      if (priority < priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    }\r\n  }\r\n\r\n  this._insertAt(ele, priority, indexToInsert);\r\n};\r\n\r\n/**\r\n * Remove element\r\n *\r\n * @param {Object} ele\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.remove = function(ele) {\r\n  var index = this._queue.length;\r\n\r\n  while (index--) {\r\n    var ele2 = this._queue[index];\r\n    if (ele === ele2) {\r\n      this._queue.splice(index, 1);\r\n      this._priorities.splice(index, 1);\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * For each loop wrapper\r\n *\r\n * @param {function} func\r\n * @returs {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.forEach = function(func) {\r\n  this._queue.forEach(func);\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElements = function() {\r\n  return this._queue;\r\n};\r\n\r\n/**\r\n * @param {number} index\r\n * @returns {Object}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementPriority = function(index) {\r\n  return this._priorities[index];\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getPriorities = function() {\r\n  return this._priorities;\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementsWithPriorities = function() {\r\n  var result = [];\r\n\r\n  for (var i = 0, l = this._queue.length; i < l; i++) {\r\n    result.push([this._queue[i], this._priorities[i]]);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._init = function(elements, priorities, sorting) {\r\n\r\n  if (elements && priorities) {\r\n    this._queue = [];\r\n    this._priorities = [];\r\n\r\n    if (elements.length !== priorities.length) {\r\n      throw new Error('Arrays must have the same length');\r\n    }\r\n\r\n    for (var i = 0; i < elements.length; i++) {\r\n      this.insert(elements[i], priorities[i]);\r\n    }\r\n  }\r\n\r\n  if (sorting) {\r\n    this._sorting = sorting;\r\n  }\r\n};\r\n\r\n/**\r\n * Insert element at given position\r\n *\r\n * @param {Object} ele\r\n * @param {number} index\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._insertAt = function(ele, priority, index) {\r\n  if (this._queue.length === index) {\r\n    this._queue.push(ele);\r\n    this._priorities.push(priority);\r\n  } else {\r\n    this._queue.splice(index, 0, ele);\r\n    this._priorities.splice(index, 0, priority);\r\n  }\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = PriorityQueue;\r\n}\r\n","\r\n/**\r\n * @requires ./PriorityQueue.js\r\n */\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n      var PriorityQueue = require('./PriorityQueue.js');\r\n}\r\n\r\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\r\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 1;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._reachability = [];\r\n  /** @type {Array} */\r\n  this._processed = [];\r\n  /** @type {number} */\r\n  this._coreDistance = 0;\r\n  /** @type {Array} */\r\n  this._orderedList = [];\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n\r\n/******************************************************************************/\r\n// pulic functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nOPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\r\n    if (this._processed[pointId] !== 1) {\r\n      this._processed[pointId] = 1;\r\n      this.clusters.push([pointId]);\r\n      var clusterId = this.clusters.length - 1;\r\n\r\n      this._orderedList.push(pointId);\r\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      // using priority queue assign elements to new cluster\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, priorityQueue);\r\n        this._expandCluster(clusterId, priorityQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\r\nOPTICS.prototype.getReachabilityPlot = function() {\r\n  var reachabilityPlot = [];\r\n\r\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\r\n    var pointId = this._orderedList[i];\r\n    var distance = this._reachability[pointId];\r\n\r\n    reachabilityPlot.push([pointId, distance]);\r\n  }\r\n\r\n  return reachabilityPlot;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this._reachability = new Array(this.dataset.length);\r\n    this._processed = new Array(this.dataset.length);\r\n    this._coreDistance = 0;\r\n    this._orderedList = [];\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {\r\n  var self = this;\r\n\r\n  this._coreDistance = this._distanceToCore(pointId);\r\n  neighbors.forEach(function(pointId2) {\r\n    if (self._processed[pointId2] === undefined) {\r\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\r\n      var newReachableDistance = Math.max(self._coreDistance, dist);\r\n\r\n      if (self._reachability[pointId2] === undefined) {\r\n        self._reachability[pointId2] = newReachableDistance;\r\n        queue.insert(pointId2, newReachableDistance);\r\n      } else {\r\n        if (newReachableDistance < self._reachability[pointId2]) {\r\n          self._reachability[pointId2] = newReachableDistance;\r\n          queue.remove(pointId2);\r\n          queue.insert(pointId2, newReachableDistance);\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._expandCluster = function(clusterId, queue) {\r\n  var queueElements = queue.getElements();\r\n\r\n  for (var p = 0, l = queueElements.length; p < l; p++) {\r\n    var pointId = queueElements[p];\r\n    if (this._processed[pointId] === undefined) {\r\n      var neighbors = this._regionQuery(pointId);\r\n      this._processed[pointId] = 1;\r\n\r\n      this.clusters[clusterId].push(pointId);\r\n      this._orderedList.push(pointId);\r\n\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, queue);\r\n        this._expandCluster(clusterId, queue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._distanceToCore = function(pointId) {\r\n  var l = this.epsilon;\r\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\r\n    var neighbors = this._regionQuery(pointId, coreDistCand);\r\n    if (neighbors.length >= this.minPts) {\r\n      return coreDistCand;\r\n    }\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nOPTICS.prototype._regionQuery = function(pointId, epsilon) {\r\n  epsilon = epsilon || this.epsilon;\r\n  var neighbors = [];\r\n\r\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\r\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = OPTICS;\r\n}\r\n","\r\nif (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = {\r\n      DBSCAN: require('./DBSCAN.js'),\r\n      KMEANS: require('./KMEANS.js'),\r\n      OPTICS: require('./OPTICS.js'),\r\n      PriorityQueue: require('./PriorityQueue.js')\r\n    };\r\n}\r\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { Units, featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersDbscan from \"@turf/clusters-dbscan\";\n\nexport interface DBScanOptions {\n  units?: Units;\n  minPoints?: number;\n  mutate?: boolean;\n}\n\nexport interface DBScanAlgorithmOptions extends ViewportAlgorithmOptions {\n  maxDistance?: number;\n  minPoints?: number;\n}\n\nconst DEFAULT_INTERNAL_DBSCAN_OPTION: DBScanOptions = {\n  units: \"kilometers\",\n  mutate: false,\n  minPoints: 1,\n};\n\n/**\n *\n * **This algorithm is not yet ready for use!**\n *\n * Experimental algorithm using DBScan.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-dbscan\n */\nexport class DBScanAlgorithm extends AbstractViewportAlgorithm {\n  protected maxDistance: number;\n  protected options: DBScanOptions;\n  constructor({\n    maxDistance = 200,\n    minPoints = DEFAULT_INTERNAL_DBSCAN_OPTION.minPoints,\n    ...options\n  }: DBScanAlgorithmOptions) {\n    super(options);\n    this.maxDistance = maxDistance;\n    this.options = {\n      ...DEFAULT_INTERNAL_DBSCAN_OPTION,\n      minPoints,\n    };\n  }\n\n  protected cluster({\n    markers,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    const points = featureCollection(\n      markers.map((marker) => {\n        const projectedPoint = mapCanvasProjection.fromLatLngToContainerPixel(\n          marker.getPosition()\n        );\n        return point([projectedPoint.x, projectedPoint.y]);\n      })\n    );\n\n    const grouped: google.maps.Marker[][] = [];\n\n    clustersDbscan(points, this.maxDistance, this.options).features.forEach(\n      (point, i) => {\n        if (!grouped[point.properties.cluster]) {\n          grouped[point.properties.cluster] = [];\n        }\n\n        grouped[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return grouped.map((markers) => new Cluster({ markers }));\n  }\n}\n","import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { coordAll } from \"@turf/meta\";\nimport { convertLength, } from \"@turf/helpers\";\nimport clustering from \"density-clustering\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\n *\n * @name clustersDbscan\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(points, maxDistance, options) {\n    // Input validation being handled by Typescript\n    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n    if (options === void 0) { options = {}; }\n    // Clone points to prevent any mutations\n    if (options.mutate !== true)\n        points = clone(points);\n    // Defaults\n    options.minPoints = options.minPoints || 3;\n    // create clustered ids\n    var dbscan = new clustering.DBSCAN();\n    var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\n    // Tag points to Clusters ID\n    var clusterId = -1;\n    clusteredIds.forEach(function (clusterIds) {\n        clusterId++;\n        // assign cluster ids to input points\n        clusterIds.forEach(function (idx) {\n            var clusterPoint = points.features[idx];\n            if (!clusterPoint.properties)\n                clusterPoint.properties = {};\n            clusterPoint.properties.cluster = clusterId;\n            clusterPoint.properties.dbscan = \"core\";\n        });\n    });\n    // handle noise points, if any\n    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n    dbscan.noise.forEach(function (noiseId) {\n        var noisePoint = points.features[noiseId];\n        if (!noisePoint.properties)\n            noisePoint.properties = {};\n        if (noisePoint.properties.cluster)\n            noisePoint.properties.dbscan = \"edge\";\n        else\n            noisePoint.properties.dbscan = \"noise\";\n    });\n    return points;\n}\nexport default clustersDbscan;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/* global ActiveXObject -- old IE, WSH */\nvar anObject = require('../internals/an-object');\nvar defineProperties = require('../internals/object-define-properties');\nvar enumBugKeys = require('../internals/enum-bug-keys');\nvar hiddenKeys = require('../internals/hidden-keys');\nvar html = require('../internals/html');\nvar documentCreateElement = require('../internals/document-create-element');\nvar sharedKey = require('../internals/shared-key');\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput, AlgorithmOutput } from \"./core\";\nimport SuperCluster, { ClusterFeature } from \"supercluster\";\n\nimport { Cluster } from \"../cluster\";\nimport equal from \"fast-deep-equal/es6\";\n\nexport type SuperClusterOptions = SuperCluster.Options<\n  { [name: string]: any },\n  { [name: string]: any }\n>;\n\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nexport class SuperClusterAlgorithm extends AbstractAlgorithm {\n  protected superCluster: SuperCluster;\n  protected markers: google.maps.Marker[];\n  protected clusters: Cluster[];\n  protected state: { zoom: number };\n\n  constructor({ maxZoom, radius = 60, ...options }: SuperClusterOptions) {\n    super({ maxZoom });\n\n    this.superCluster = new SuperCluster({\n      maxZoom: this.maxZoom,\n      radius,\n      ...options,\n    });\n\n    this.state = { zoom: null };\n  }\n  public calculate(input: AlgorithmInput): AlgorithmOutput {\n    let changed = false;\n\n    if (!equal(input.markers, this.markers)) {\n      changed = true;\n      // TODO use proxy to avoid copy?\n      this.markers = [...input.markers];\n\n      const points = this.markers.map((marker) => {\n        return {\n          type: \"Feature\" as const,\n          geometry: {\n            type: \"Point\" as const,\n            coordinates: [\n              marker.getPosition().lng(),\n              marker.getPosition().lat(),\n            ],\n          },\n          properties: { marker },\n        };\n      });\n\n      this.superCluster.load(points);\n    }\n\n    const state = { zoom: input.map.getZoom() };\n\n    if (!changed) {\n      if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) {\n        // still beyond maxZoom, no change\n      } else {\n        changed = changed || !equal(this.state, state);\n      }\n    }\n\n    this.state = state;\n\n    if (changed) {\n      this.clusters = this.cluster(input);\n    }\n\n    return { clusters: this.clusters, changed };\n  }\n\n  public cluster({ map }: AlgorithmInput): Cluster[] {\n    return this.superCluster\n      .getClusters([-180, -90, 180, 90], map.getZoom())\n      .map(this.transformCluster.bind(this));\n  }\n\n  protected transformCluster({\n    geometry: {\n      coordinates: [lng, lat],\n    },\n    properties,\n  }: ClusterFeature<{ marker: google.maps.Marker }>): Cluster {\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster\n          .getLeaves(properties.cluster_id, Infinity)\n          .map((leaf) => leaf.properties.marker),\n        position: new google.maps.LatLng({ lat, lng }),\n      });\n    } else {\n      const marker = properties.marker;\n\n      return new Cluster({\n        markers: [marker],\n        position: marker.getPosition(),\n      });\n    }\n  }\n}\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar anObject = require('../internals/an-object');\nvar objectKeys = require('../internals/object-keys');\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n","var wellKnownSymbol = require('../internals/well-known-symbol');\nvar create = require('../internals/object-create');\nvar definePropertyModule = require('../internals/object-define-property');\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $includes = require('../internals/array-includes').includes;\nvar addToUnscopables = require('../internals/add-to-unscopables');\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$({ target: 'Array', proto: true }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n","var isObject = require('../internals/is-object');\nvar classof = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n","var isRegExp = require('../internals/is-regexp');\n\nmodule.exports = function (it) {\n  if (isRegExp(it)) {\n    throw TypeError(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n","var classof = require('../internals/classof');\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return String(argument);\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\n\nmodule.exports = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar notARegExp = require('../internals/not-a-regexp');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~toString(requireObjectCoercible(this))\n      .indexOf(toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar toPropertyKey = require('../internals/to-property-key');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar toObject = require('../internals/to-object');\nvar arraySpeciesCreate = require('../internals/array-species-create');\nvar createProperty = require('../internals/create-property');\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');\n\nvar max = Math.max;\nvar min = Math.min;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';\n\n// `Array.prototype.splice` method\n// https://tc39.es/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  splice: function splice(start, deleteCount /* , ...items */) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var actualStart = toAbsoluteIndex(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);\n    }\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {\n      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n    A = arraySpeciesCreate(O, actualDeleteCount);\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty(A, k, O[from]);\n    }\n    A.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n    }\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n    O.length = len - actualDeleteCount + insertCount;\n    return A;\n  }\n});\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (argument) {\n  if (typeof argument === 'object' || isCallable(argument)) return argument;\n  throw TypeError(\"Can't set \" + String(argument) + ' as a prototype');\n};\n","/* eslint-disable no-proto -- safe */\nvar anObject = require('../internals/an-object');\nvar aPossiblePrototype = require('../internals/a-possible-prototype');\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n","var isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n","var valueOf = 1.0.valueOf;\n\n// `thisNumberValue` abstract operation\n// https://tc39.es/ecma262/#sec-thisnumbervalue\nmodule.exports = function (value) {\n  return valueOf.call(value);\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = toString(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar isForced = require('../internals/is-forced');\nvar redefine = require('../internals/redefine');\nvar hasOwn = require('../internals/has-own-property');\nvar inheritIfRequired = require('../internals/inherit-if-required');\nvar isSymbol = require('../internals/is-symbol');\nvar toPrimitive = require('../internals/to-primitive');\nvar fails = require('../internals/fails');\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar defineProperty = require('../internals/object-define-property').f;\nvar thisNumberValue = require('../internals/this-number-value');\nvar trim = require('../internals/string-trim').trim;\n\nvar NUMBER = 'Number';\nvar NativeNumber = global[NUMBER];\nvar NumberPrototype = NativeNumber.prototype;\n\n// `ToNumeric` abstract operation\n// https://tc39.es/ecma262/#sec-tonumeric\nvar toNumeric = function (value) {\n  var primValue = toPrimitive(value, 'number');\n  return typeof primValue === 'bigint' ? primValue : toNumber(primValue);\n};\n\n// `ToNumber` abstract operation\n// https://tc39.es/ecma262/#sec-tonumber\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, 'number');\n  var first, third, radix, maxCode, digits, length, index, code;\n  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');\n  if (typeof it == 'string' && it.length > 2) {\n    it = trim(it);\n    first = it.charCodeAt(0);\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i\n        default: return +it;\n      }\n      digits = it.slice(2);\n      length = digits.length;\n      for (index = 0; index < length; index++) {\n        code = digits.charCodeAt(index);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\n// `Number` constructor\n// https://tc39.es/ecma262/#sec-number-constructor\nif (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {\n  var NumberWrapper = function Number(value) {\n    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));\n    var dummy = this;\n    // check on 1..constructor(foo) case\n    return dummy instanceof NumberWrapper && fails(function () { thisNumberValue(dummy); })\n      ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;\n  };\n  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES2015 (in case, if modules with ES2015 Number statics required before):\n    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +\n    // ESNext\n    'fromString,range'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {\n      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n    }\n  }\n  NumberWrapper.prototype = NumberPrototype;\n  NumberPrototype.constructor = NumberWrapper;\n  redefine(global, NUMBER, NumberWrapper);\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"./cluster\";\n\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nexport class ClusterStats {\n  public readonly markers: { sum: number };\n  public readonly clusters: {\n    count: number;\n    markers: {\n      mean: number;\n      sum: number;\n      min: number;\n      max: number;\n    };\n  };\n\n  constructor(markers: google.maps.Marker[], clusters: Cluster[]) {\n    this.markers = { sum: markers.length };\n\n    const clusterMarkerCounts = clusters.map((a) => a.count);\n    const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts),\n      },\n    };\n  }\n}\n\nexport interface Renderer {\n  /**\n   * Turn a {@link Cluster} into a `google.maps.Marker`.\n   *\n   * Below is a simple example to create a marker with the number of markers in the cluster as a label.\n   *\n   * ```typescript\n   * return new google.maps.Marker({\n   *   position,\n   *   label: String(markers.length),\n   * });\n   * ```\n   */\n  render(cluster: Cluster, stats: ClusterStats): google.maps.Marker;\n}\n\nexport class DefaultRenderer implements Renderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  public render(\n    { count, position }: Cluster,\n    stats: ClusterStats\n  ): google.maps.Marker {\n    // change color if this cluster has more markers than the mean cluster\n    const color =\n      count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n\n    // create svg url with fill color\n    const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n  </svg>`);\n\n    // create marker using svg icon\n    return new google.maps.Marker({\n      position,\n      icon: {\n        url: `data:image/svg+xml;base64,${svg}`,\n        scaledSize: new google.maps.Size(45, 45),\n      },\n      label: {\n        text: String(count),\n        color: \"rgba(255,255,255,0.9)\",\n        fontSize: \"12px\",\n      },\n      // adjust zIndex to be above other markers\n      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n    });\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Algorithm, SuperClusterAlgorithm } from \"./algorithms\";\nimport { ClusterStats, DefaultRenderer, Renderer } from \"./renderer\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\nexport type onClusterClickHandler = (\n  event: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n) => void;\nexport interface MarkerClustererOptions {\n  markers?: google.maps.Marker[];\n  /**\n   * An algorithm to cluster markers. Default is {@link SuperClusterAlgorithm}. Must\n   * provide a `calculate` method accepting {@link AlgorithmInput} and returning\n   * an array of {@link Cluster}.\n   */\n  algorithm?: Algorithm;\n  map?: google.maps.Map | null;\n  /**\n   * An object that converts a {@link Cluster} into a `google.maps.Marker`.\n   * Default is {@link DefaultRenderer}.\n   */\n  renderer?: Renderer;\n  onClusterClick?: onClusterClickHandler;\n}\n\nexport enum MarkerClustererEvents {\n  CLUSTERING_BEGIN = \"clusteringbegin\",\n  CLUSTERING_END = \"clusteringend\",\n  CLUSTER_CLICK = \"click\",\n}\n\nexport const defaultOnClusterClickHandler: onClusterClickHandler = (\n  _: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n): void => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n * <iframe src=\"https://googlemaps.github.io/js-three/public/anchor/index.html\"></iframe>\n */\nexport class MarkerClusterer extends OverlayViewSafe {\n  /** @see {@link MarkerClustererOptions.onClusterClick} */\n  public onClusterClick: onClusterClickHandler;\n  /** @see {@link MarkerClustererOptions.algorithm} */\n  protected algorithm: Algorithm;\n  protected clusters: Cluster[];\n  protected markers: google.maps.Marker[];\n  /** @see {@link MarkerClustererOptions.renderer} */\n  protected renderer: Renderer;\n  /** @see {@link MarkerClustererOptions.map} */\n  protected map: google.maps.Map | null;\n  /** @see {@link MarkerClustererOptions.maxZoom} */\n  protected idleListener: google.maps.MapsEventListener;\n\n  constructor({\n    map,\n    markers = [],\n    algorithm = new SuperClusterAlgorithm({}),\n    renderer = new DefaultRenderer(),\n    onClusterClick = defaultOnClusterClickHandler,\n  }: MarkerClustererOptions) {\n    super();\n    this.markers = [...markers];\n    this.clusters = [];\n\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n\n    this.onClusterClick = onClusterClick;\n\n    if (map) {\n      this.setMap(map);\n    }\n  }\n\n  public addMarker(marker: google.maps.Marker, noDraw?: boolean): void {\n    if (this.markers.includes(marker)) {\n      return;\n    }\n\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public addMarkers(markers: google.maps.Marker[], noDraw?: boolean): void {\n    markers.forEach((marker) => {\n      this.addMarker(marker, true);\n    });\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public removeMarker(marker: google.maps.Marker, noDraw?: boolean): boolean {\n    const index = this.markers.indexOf(marker);\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n\n    if (!noDraw) {\n      this.render();\n    }\n\n    return true;\n  }\n\n  public removeMarkers(\n    markers: google.maps.Marker[],\n    noDraw?: boolean\n  ): boolean {\n    let removed = false;\n\n    markers.forEach((marker) => {\n      removed = this.removeMarker(marker, true) || removed;\n    });\n\n    if (removed && !noDraw) {\n      this.render();\n    }\n\n    return removed;\n  }\n\n  public clearMarkers(noDraw?: boolean): void {\n    this.markers.length = 0;\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  public render(): void {\n    const map = this.getMap();\n    if (map instanceof google.maps.Map && this.getProjection()) {\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_BEGIN,\n        this\n      );\n      const { clusters, changed } = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection(),\n      });\n\n      // allow algorithms to return flag on whether the clusters/markers have changed\n      if (changed || changed == undefined) {\n        // reset visibility of markers and clusters\n        this.reset();\n\n        // store new clusters\n        this.clusters = clusters;\n\n        this.renderClusters();\n      }\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_END,\n        this\n      );\n    }\n  }\n\n  public onAdd(): void {\n    this.idleListener = this.getMap().addListener(\n      \"idle\",\n      this.render.bind(this)\n    );\n    this.render();\n  }\n\n  public onRemove(): void {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n\n  protected reset(): void {\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.clusters.forEach((cluster) => cluster.delete());\n    this.clusters = [];\n  }\n\n  protected renderClusters(): void {\n    // generate stats to pass to renderers\n    const stats = new ClusterStats(this.markers, this.clusters);\n    const map = this.getMap() as google.maps.Map;\n\n    this.clusters.forEach((cluster) => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        cluster.marker = this.renderer.render(cluster, stats);\n\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\n            \"click\",\n            /* istanbul ignore next */\n            (event: google.maps.MapMouseEvent) => {\n              google.maps.event.trigger(\n                this,\n                MarkerClustererEvents.CLUSTER_CLICK,\n                cluster\n              );\n              this.onClusterClick(event, cluster, map);\n            }\n          );\n        }\n      }\n\n      cluster.marker.setMap(map);\n    });\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n"],"names":["match","version","check","it","Math","globalThis","window","self","global","this","Function","exec","error","fails","Object","defineProperty","get","$propertyIsEnumerable","propertyIsEnumerable","getOwnPropertyDescriptor","call","V","descriptor","enumerable","bitmap","value","configurable","writable","toString","slice","split","classof","undefined","TypeError","IndexedObject","requireObjectCoercible","argument","isCallable","aFunction","namespace","method","arguments","length","getBuiltIn","process","Deno","versions","v8","userAgent","getOwnPropertySymbols","symbol","Symbol","String","sham","V8_VERSION","NATIVE_SYMBOL","iterator","USE_SYMBOL_AS_UID","$Symbol","tryToString","key","SHARED","setGlobal","module","store","push","mode","copyright","hasOwnProperty","hasOwn","toObject","id","postfix","random","WellKnownSymbolsStore","shared","createWellKnownSymbol","withoutSetter","uid","name","TO_PRIMITIVE","wellKnownSymbol","input","pref","isObject","isSymbol","func","result","exoticToPrim","aCallable","fn","val","valueOf","ordinaryToPrimitive","toPrimitive","document","EXISTS","createElement","DESCRIPTORS","a","$getOwnPropertyDescriptor","O","P","toIndexedObject","toPropertyKey","IE8_DOM_DEFINE","createPropertyDescriptor","propertyIsEnumerableModule","f","$defineProperty","Attributes","anObject","object","definePropertyModule","functionToString","inspectSource","set","has","WeakMap","test","keys","OBJECT_ALREADY_INITIALIZED","NATIVE_WEAK_MAP","state","wmget","wmhas","wmset","metadata","facade","STATE","sharedKey","hiddenKeys","createNonEnumerableProperty","enforce","getterFor","TYPE","type","FunctionPrototype","prototype","getDescriptor","PROPER","CONFIGURABLE","CONFIGURABLE_FUNCTION_NAME","require$$0","getInternalState","InternalStateModule","enforceInternalState","TEMPLATE","options","unsafe","simple","noTargetGet","replace","source","join","ceil","floor","number","max","min","index","integer","toIntegerOrInfinity","obj","createMethod","IS_INCLUDES","$this","el","fromIndex","lengthOfArrayLike","toAbsoluteIndex","includes","indexOf","names","i","enumBugKeys","concat","getOwnPropertyNames","internalObjectKeys","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","target","ownKeys","getOwnPropertyDescriptorModule","replacement","isForced","feature","detection","data","normalize","POLYFILL","NATIVE","string","toLowerCase","targetProperty","sourceProperty","TARGET","GLOBAL","STATIC","stat","forced","copyConstructorProperties","redefine","Array","isArray","TO_STRING_TAG","CORRECT_ARGUMENTS","classofRaw","TO_STRING_TAG_SUPPORT","tag","tryGet","callee","empty","construct","constructorRegExp","INCORRECT_TO_STRING","isConstructorModern","called","SPECIES","originalArray","C","constructor","isConstructor","IS_MAP","IS_FILTER","IS_SOME","IS_EVERY","IS_FIND_INDEX","IS_FILTER_REJECT","NO_HOLES","callbackfn","that","specificCreate","boundFunction","b","c","apply","bind","create","arraySpeciesCreate","forEach","map","filter","some","every","find","findIndex","filterReject","METHOD_NAME","array","foo","Boolean","$map","proto","arrayMethodHasSpeciesSupport","$filter","Cluster","markers","position","google","maps","LatLng","_position","reduce","bounds","marker","extend","getPosition","LatLngBounds","getCenter","m","getVisible","setMap","filterMarkersToPaddedViewport","mapCanvasProjection","viewportPadding","extendedMapBounds","extendBoundsToPaddedViewport","getBounds","contains","projection","pixels","latLngBoundsToPixelBounds","northEast","southWest","extendedPixelBounds","extendPixelBounds","pixelBoundsToLatLngBounds","distanceBetweenPoints","p1","p2","dLat","lat","PI","dLon","lng","sin","cos","atan2","sqrt","fromLatLngToDivPixel","getNorthEast","getSouthWest","x","y","fromDivPixelToLatLng","AbstractAlgorithm","maxZoom","noop","AbstractViewportAlgorithm","_a","getZoom","clusters","changed","cluster","CSSRuleList","CSSStyleDeclaration","CSSValueList","ClientRectList","DOMRectList","DOMStringList","DOMTokenList","DataTransferItemList","FileList","HTMLAllCollection","HTMLCollection","HTMLFormElement","HTMLSelectElement","MediaList","MimeTypeArray","NamedNodeMap","NodeList","PaintRequestList","Plugin","PluginArray","SVGLengthList","SVGNumberList","SVGPathSegList","SVGPointList","SVGStringList","SVGTransformList","SourceBufferList","StyleSheetList","TextTrackCueList","TextTrackList","TouchList","classList","documentCreateElement","DOMTokenListPrototype","$forEach","handlePrototype","CollectionPrototype","COLLECTION_NAME","DOMIterables","toJSON","URL","GridAlgorithm","maxDistance","gridSize","_this2","addToClosestCluster","candidate","distance","NoopAlgorithm","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","point","coordinates","properties","Error","isNumber","geom","feat","bbox","geometry","featureCollection","features","fc","radiansToLength","units","factor","degreesToRadians","convertLength","originalUnit","finalUnit","lengthToRadians","num","isNaN","clone","geojson","cloneFeature","cloned","cloneFeatureCollection","cloneGeometry","cloneProperties","item","geometries","g","deepSlice","coords","coord","coordEach","callback","excludeWrapCoord","j","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordAll","len","ks","d","prs","v","vlen","kmpp","init","count","Infinity","dist","old","vsum","sum","h","ksj","_j3","cj","_i2","KmeansAlgorithm","numberOfClusters","points","round","mutate","initialCentroids","skmeansResult","skmeans","centroids","idx","featureEach","clusterId","idxs","centroid","clustersKmeans","$assign","assign","A","B","alphabet","chr","objectKeys","T","argumentsLength","S","getCoord","from","to","coordinates1","coordinates2","lat1","lat2","pow","DBSCAN","dataset","epsilon","minPts","distanceFunction","_euclideanDistance","noise","_visited","_assigned","_datasetLength","_init","run","pointId","neighbors","_regionQuery","_addToCluster","_expandCluster","pointId2","neighbors2","_mergeArrays","p","q","exports","KMEANS","assignments","randomCentroid","change","centroidId","mean","maxDim","dim","getClusters","maxId","closestCentroid","argmin","Number","MAX_VALUE","arg","diff","PriorityQueue","elements","priorities","sorting","_queue","_priorities","_sorting","insert","ele","priority","indexToInsert","priority2","_insertAt","remove","splice","getElements","getElementPriority","getPriorities","getElementsWithPriorities","OPTICS","_reachability","_processed","_coreDistance","_orderedList","priorityQueue","_distanceToCore","_updateQueue","getReachabilityPlot","reachabilityPlot","queue","newReachableDistance","queueElements","coreDistCand","require$$1","require$$2","require$$3","DEFAULT_INTERNAL_DBSCAN_OPTION","minPoints","DBScanAlgorithm","projectedPoint","fromLatLngToContainerPixel","grouped","dbscan","clustering","clusteredIds","clusterIds","clusterPoint","noiseId","noisePoint","clustersDbscan","sortKD","ids","nodeSize","left","right","depth","select","inc","n","z","log","s","exp","sd","t","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","dx","dy","defaultGetX","defaultGetY","KDBush","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","sort","range","minX","minY","maxX","maxY","stack","axis","pop","nextAxis","within","r","qx","qy","r2","defaultOptions","minZoom","radius","extent","generateId","props","fround","Float32Array","Supercluster","trees","load","console","time","timerId","createPointCluster","timeEnd","now","Date","_cluster","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","tree","_limitZoom","lngX","latY","numPoints","getClusterJSON","getChildren","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","origin","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","_addTileFeatures","getClusterExpansionZoom","expansionZoom","cluster_id","skipped","child","point_count","isCluster","tags","px","py","getClusterProperties","neighborIds","numPointsOrigin","neighborId","wx","wy","clusterProperties","_map","numPoints2","createCluster","original","yLat","abbrev","point_count_abbreviated","y2","atan","dest","src","activeXDocument","equal","Map","size","entries","Set","ArrayBuffer","isView","RegExp","flags","SuperClusterAlgorithm","superCluster","SuperCluster","_this","transformCluster","leaf","defineProperties","Properties","IE_PROTO","EmptyConstructor","scriptTag","content","LT","NullProtoObjectViaActiveX","write","close","temp","parentWindow","NullProtoObject","ActiveXObject","iframeDocument","iframe","domain","style","display","html","appendChild","contentWindow","open","F","UNSCOPABLES","ArrayPrototype","$includes","addToUnscopables","MATCH","isRegExp","regexp","error1","error2","correctIsRegExpLogic","searchString","notARegExp","propertyKey","HAS_SPECIES_SUPPORT","MAX_SAFE_INTEGER","MAXIMUM_ALLOWED_LENGTH_EXCEEDED","start","deleteCount","insertCount","actualDeleteCount","actualStart","createProperty","setPrototypeOf","setter","CORRECT_SETTER","aPossiblePrototype","__proto__","dummy","Wrapper","NewTarget","NewTargetPrototype","whitespace","ltrim","rtrim","end","trim","NUMBER","NativeNumber","NumberPrototype","toNumeric","primValue","toNumber","first","third","radix","maxCode","digits","code","charCodeAt","NaN","parseInt","NumberWrapper","thisNumberValue","inheritIfRequired","ClusterStats","clusterMarkerCounts","clusterMarkerSum","DefaultRenderer","stats","color","svg","btoa","Marker","icon","url","scaledSize","Size","label","text","fontSize","zIndex","MAX_ZINDEX","MarkerClustererEvents","OverlayViewSafe","type1","type2","property","OverlayView","defaultOnClusterClickHandler","_","fitBounds","MarkerClusterer","algorithm","renderer","onClusterClick","noDraw","render","addMarker","removed","_this3","removeMarker","getMap","getProjection","event","trigger","CLUSTERING_BEGIN","calculate","reset","renderClusters","CLUSTERING_END","idleListener","addListener","removeListener","delete","_this4","CLUSTER_CLICK"],"mappings":"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"}